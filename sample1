###############################################################################
# modify_webauthn.py  ―  WebAuthn メッセージ改変ツール（v1.4）
#
# v1.4 変更点 ─────────────────────────────────────────────────────────
#  ▸ attestationObject しか入力されないケースでも authData を内部抽出し、
#    --set‑rpid / --clear‑UP など “authData 系オプション” が動作するよう統合。
#  ▸ 処理フロー
#       ① 入力優先度:  --authdata があればそれを使用
#                      無ければ --attobj から抽出した authData を使用
#       ② 変更後は必要に応じて attestationObject.authData を置き換え
#  ▸ 変更ログ強化:  attestationObject 埋め戻し時に必ず詳細を stderr 出力
#
#   依存:  Python ≥3.8 / pip install cbor2
###############################################################################
import argparse
import base64
import hashlib
import json
import os
import struct
import sys
from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import cbor2  # オフライン環境ではあらかじめ pip install 済みであること

# ---------- 共通ユーティリティ ------------------------------------------------
def b64url_decode(s: str) -> bytes:
    return base64.urlsafe_b64decode(s + "=" * (-len(s) % 4))


def b64url_encode(b: bytes) -> str:
    return base64.urlsafe_b64encode(b).decode().rstrip("=")


# ---------- clientDataJSON ---------------------------------------------------
def decode_client(b64: str) -> Dict[str, Any]:
    return json.loads(b64url_decode(b64))


def encode_client(obj: Dict[str, Any]) -> str:
    return b64url_encode(json.dumps(obj, separators=(",", ":")).encode())


# ---------- attestationObject ------------------------------------------------
def decode_attobj(b64: str) -> Dict[str, Any]:
    return cbor2.loads(b64url_decode(b64))


def encode_attobj(obj: Dict[str, Any]) -> str:
    return b64url_encode(cbor2.dumps(obj))


# ---------- authenticatorData ------------------------------------------------
@dataclass
class AuthData:
    rp_hash: bytes
    flags: int
    counter: int
    acd: bytes
    ext: bytes


FLAG_UP = 0x01
FLAG_UV = 0x04


def _cbor_peek(buf: bytes) -> Tuple[Any, int]:
    dec = cbor2.CBORDecoder(buf)
    v = dec.decode()
    return v, dec.tell()


def _split_auth(buf: bytes) -> AuthData:
    rp_hash = buf[:32]
    flags = buf[32]
    counter = struct.unpack(">I", buf[33:37])[0]
    rest = buf[37:]

    if flags & 0x40:  # AT = 1
        aaguid = rest[:16]
        cred_len = struct.unpack(">H", rest[16:18])[0]
        pk_start = 18 + cred_len
        _, used = _cbor_peek(rest[pk_start:])
        acd_len = 16 + 2 + cred_len + used
        acd, ext = rest[:acd_len], rest[acd_len:]
    else:
        acd, ext = b"", rest

    return AuthData(rp_hash, flags, counter, acd, ext)


def decode_auth(b64: str) -> AuthData:
    return _split_auth(b64url_decode(b64))


def encode_auth(ad: AuthData) -> str:
    parts = [
        ad.rp_hash,
        struct.pack("B", ad.flags),
        struct.pack(">I", ad.counter),
        ad.acd,
        ad.ext,
    ]
    return b64url_encode(b"".join(parts))


# ---------- メイン改変ロジック ----------------------------------------------
def modify(
    client_b64: Optional[str],
    att_b64: Optional[str],
    auth_b64: Optional[str],
    *,
    set_origin: Optional[str],
    set_chal: Optional[str],
    set_rpid: Optional[str],
    up_ops: Tuple[bool, bool],  # (clear, set)
    uv_ops: Tuple[bool, bool],
    counter_val: Optional[int],
    outfile: Optional[str],
):
    # 1) 入力ソース取得
    att_dict = decode_attobj(att_b64) if att_b64 else None

    if auth_b64:
        auth_src_b64 = auth_b64
    elif att_dict:
        auth_src_b64 = b64url_encode(att_dict["authData"])
    else:
        auth_src_b64 = None

    # 2) clientDataJSON 改変
    new_client = client_b64
    if client_b64 and (set_origin or set_chal):
        cd = decode_client(client_b64)
        if set_origin:
            print(f"[clientDataJSON] origin: {cd.get('origin')} -> {set_origin}", file=sys.stderr)
            cd["origin"] = set_origin
        if set_chal:
            rand = os.urandom(32) if set_chal.lower() == "random" else None
            chal = b64url_encode(rand) if rand else set_chal
            print(f"[clientDataJSON] challenge -> {chal}", file=sys.stderr)
            cd["challenge"] = chal
        new_client = encode_client(cd)

    # 3) authenticatorData 改変
    new_auth = auth_src_b64
    if auth_src_b64 and (
        any(up_ops) or any(uv_ops) or counter_val is not None or set_rpid
    ):
        ad = decode_auth(auth_src_b64)
        if up_ops[0]:
            ad.flags &= ~FLAG_UP
        if up_ops[1]:
            ad.flags |= FLAG_UP
        if uv_ops[0]:
            ad.flags &= ~FLAG_UV
        if uv_ops[1]:
            ad.flags |= FLAG_UV
        if counter_val is not None:
            print(f"[authenticatorData] counter: {ad.counter} -> {counter_val}", file=sys.stderr)
            ad.counter = counter_val
        if set_rpid:
            new_hash = hashlib.sha256(set_rpid.encode()).digest()
            print(f"[authenticatorData] rpIdHash -> {new_hash.hex()}", file=sys.stderr)
            ad.rp_hash = new_hash
        new_auth = encode_auth(ad)

    # 4) attestationObject 埋め戻し
    new_att = att_b64
    if att_dict and new_auth and new_auth != auth_src_b64:
        att_dict["authData"] = b64url_decode(new_auth)
        new_att = encode_attobj(att_dict)
        print("[attestationObject] authData field updated", file=sys.stderr)

    # 5) 出力
    kv = []
    if new_client:
        kv.append(f"clientDataJSON={new_client}")
    if new_auth:
        kv.append(f"authenticatorData={new_auth}")
    if new_att:
        kv.append(f"attestationObject={new_att}")

    payload = "&".join(kv)
    if outfile:
        with open(outfile, "w", encoding="utf-8") as f:
            f.write(payload)
        print(f"[+] written: {outfile}", file=sys.stderr)
    else:
        print(payload)


# ---------- CLI --------------------------------------------------------------
if __name__ == "__main__":
    p = argparse.ArgumentParser("WebAuthn message modifier v1.4")
    p.add_argument("--client", help="Base64URL clientDataJSON")
    p.add_argument("--attobj", help="Base64URL attestationObject (registration)")
    p.add_argument("--authdata", help="Base64URL authenticatorData (assertion)")

    p.add_argument("--set-origin", help="Rewrite clientDataJSON.origin")
    p.add_argument(
        "--set-challenge",
        help='Rewrite clientDataJSON.challenge ("random" for 32B random)',
    )
    p.add_argument("--set-rpid", help="Rewrite rpIdHash with SHA‑256(rpid)")
    p.add_argument("--clear-UP", action="store_true", help="Clear UserPresence bit")
    p.add_argument("--set-UP", action="store_true", help="Set UserPresence bit")
    p.add_argument("--clear-UV", action="store_true", help="Clear UserVerification bit")
    p.add_argument("--set-UV", action="store_true", help="Set UserVerification bit")
    p.add_argument("--counter", type=int, help="Overwrite signatureCounter")
    p.add_argument("--output", help="Write modified payload to file")

    args = p.parse_args()
    if not any([args.client, args.attobj, args.authdata]):
        p.error("require at least --client or --attobj or --authdata")

    modify(
        client_b64=args.client,
        att_b64=args.attobj,
        auth_b64=args.authdata,
        set_origin=args.set_origin,
        set_chal=args.set_challenge,
        set_rpid=args.set_rpid,
        up_ops=(args.clear_UP, args.set_UP),
        uv_ops=(args.clear_UV, args.set_UV),
        counter_val=args.counter,
        outfile=args.output,
    )
