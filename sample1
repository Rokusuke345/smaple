###############################################################################
# modify_webauthn.py  ―  WebAuthn メッセージ改変ツール（CLI 手動診断支援・v1.2）
#
# 変更点 v1.2
#   • --set-challenge 追加
#       ─ "random" 指定で 32 byte 乱数を生成し Base64URL へ
#       ─ 任意の Base64URL 文字列をそのまま設定することも可
#   • rpIdHash 書き換え (--set-rpid) は内部で SHA‑256 を計算（前バージョン維持）
#
# 依存ライブラリ : Python ≥3.8 / pip install cbor2
###############################################################################
import argparse
import base64
import hashlib
import json
import os
import struct
import sys
from dataclasses import dataclass
from typing import Any, Dict, Optional, Tuple

import cbor2  # pip install cbor2

# ─────────────────────────────────────────────────────────────────────
# Base64URL helper
# ─────────────────────────────────────────────────────────────────────
def b64url_decode(inp: str) -> bytes:
    pad = "=" * (-len(inp) % 4)
    return base64.urlsafe_b64decode(inp + pad)


def b64url_encode(buf: bytes) -> str:
    return base64.urlsafe_b64encode(buf).decode().rstrip("=")


# ─────────────────────────────────────────────────────────────────────
# clientDataJSON helpers
# ─────────────────────────────────────────────────────────────────────
def decode_client(b64: str) -> Dict[str, Any]:
    return json.loads(b64url_decode(b64))


def encode_client(obj: Dict[str, Any]) -> str:
    return b64url_encode(json.dumps(obj, separators=(",", ":")).encode())


# ─────────────────────────────────────────────────────────────────────
# attestationObject helpers
# ─────────────────────────────────────────────────────────────────────
def decode_attobj(b64: str) -> Dict[str, Any]:
    return cbor2.loads(b64url_decode(b64))


def encode_attobj(obj: Dict[str, Any]) -> str:
    return b64url_encode(cbor2.dumps(obj))


# ─────────────────────────────────────────────────────────────────────
# authenticatorData helpers
# ─────────────────────────────────────────────────────────────────────
@dataclass
class AuthData:
    rp_hash: bytes
    flags: int
    counter: int
    acd: bytes
    ext: bytes


def _cbor_peek(buf: bytes) -> Tuple[Any, int]:
    dec = cbor2.CBORDecoder(buf)
    val = dec.decode()
    return val, dec.tell()


def _split_authdata(buf: bytes) -> AuthData:
    rp_hash = buf[0:32]
    flags = buf[32]
    counter = struct.unpack(">I", buf[33:37])[0]
    rest = buf[37:]

    # AT(0x40) present?
    if flags & 0x40:
        aaguid = rest[0:16]
        cred_len = struct.unpack(">H", rest[16:18])[0]
        cbor_start = 18 + cred_len
        _, used = _cbor_peek(rest[cbor_start:])
        acd_len = 16 + 2 + cred_len + used
        acd = rest[:acd_len]
        ext = rest[acd_len:]
    else:
        acd, ext = b"", rest

    return AuthData(rp_hash, flags, counter, acd, ext)


def decode_authdata(b64: str) -> AuthData:
    return _split_authdata(b64url_decode(b64))


def encode_authdata(ad: AuthData) -> str:
    parts = [
        ad.rp_hash,
        struct.pack("B", ad.flags),
        struct.pack(">I", ad.counter),
        ad.acd,
        ad.ext,
    ]
    return b64url_encode(b"".join(parts))


# ─────────────────────────────────────────────────────────────────────
# CLI modify routine
# ─────────────────────────────────────────────────────────────────────
FLAG_UP = 0x01
FLAG_UV = 0x04


def modify(
    client_b64: Optional[str],
    authdata_b64: Optional[str],
    att_b64: Optional[str],
    set_origin: Optional[str],
    set_challenge: Optional[str],
    set_rpid: Optional[str],
    clear_up: bool,
    set_up: bool,
    clear_uv: bool,
    set_uv: bool,
    counter: Optional[int],
    output: Optional[str],
):
    new_client, new_authdata, new_att = client_b64, authdata_b64, att_b64

    # --- clientDataJSON modifications ---
    if client_b64 and (set_origin or set_challenge):
        cdj = decode_client(client_b64)

        if set_origin:
            print(
                f"[clientDataJSON] origin: {cdj.get('origin')} -> {set_origin}",
                file=sys.stderr,
            )
            cdj["origin"] = set_origin

        if set_challenge:
            if set_challenge.lower() == "random":
                rand = os.urandom(32)
                new_chal = b64url_encode(rand)
            else:
                new_chal = set_challenge
            print(
                f"[clientDataJSON] challenge replaced with {new_chal}",
                file=sys.stderr,
            )
            cdj["challenge"] = new_chal

        new_client = encode_client(cdj)

    # --- authenticatorData modifications ---
    if authdata_b64 and (
        clear_up
        or set_up
        or clear_uv
        or set_uv
        or counter is not None
        or set_rpid
    ):
        ad = decode_authdata(authdata_b64)
        orig_flags, orig_counter = ad.flags, ad.counter

        if clear_up:
            ad.flags &= ~FLAG_UP
        if set_up:
            ad.flags |= FLAG_UP
        if clear_uv:
            ad.flags &= ~FLAG_UV
        if set_uv:
            ad.flags |= FLAG_UV
        if counter is not None:
            ad.counter = counter
        if set_rpid:
            new_hash = hashlib.sha256(set_rpid.encode("utf-8")).digest()
            print(
                f"[authenticatorData] rpIdHash: {ad.rp_hash.hex()} -> {new_hash.hex()}",
                file=sys.stderr,
            )
            ad.rp_hash = new_hash

        if (orig_flags != ad.flags) or (orig_counter != ad.counter):
            print(
                f"[authenticatorData] flags 0x{orig_flags:02x}->{ad.flags:02x}, "
                f"counter {orig_counter}->{ad.counter}",
                file=sys.stderr,
            )

        new_authdata = encode_authdata(ad)

    # --- attestationObject update if needed ---
    if att_b64 and new_authdata != authdata_b64:
        ao = decode_attobj(att_b64)
        ao["authData"] = b64url_decode(new_authdata)
        new_att = encode_attobj(ao)

    # --- build output payload ---
    kv = []
    if new_client:
        kv.append(f"clientDataJSON={new_client}")
    if new_authdata:
        kv.append(f"authenticatorData={new_authdata}")
    if new_att:
        kv.append(f"attestationObject={new_att}")

    payload = "&".join(kv)
    if output:
        with open(output, "w", encoding="utf-8") as fout:
            fout.write(payload)
        print(f"[+] payload written to {output}", file=sys.stderr)
    else:
        print(payload)


# ─────────────────────────────────────────────────────────────────────
# Self‑test suite
# ─────────────────────────────────────────────────────────────────────
def selftest():
    ok = True
    # Base64URL round‑trip
    s = "aGVsbG8gd29ybGQ"
    ok &= b64url_encode(b64url_decode(s)) == s

    # Flag operations
    dummy = b"\0" * 32 + b"\x05" + b"\0\0\0\x02"
    ad = decode_authdata(b64url_encode(dummy))
    ad.flags &= ~FLAG_UP
    ok &= not (decode_authdata(encode_authdata(ad)).flags & FLAG_UP)

    # rpIdHash replacement
    ad2 = decode_authdata(b64url_encode(dummy))
    new_hash = hashlib.sha256(b"evil.example").digest()
    ad2.rp_hash = new_hash
    ok &= decode_authdata(encode_authdata(ad2)).rp_hash == new_hash

    # challenge random
    rand = os.urandom(32)
    chal = b64url_encode(rand)
    ok &= len(chal) > 0 and "=" not in chal

    print("[SELFTEST] OK" if ok else "[SELFTEST] FAIL", file=sys.stderr)
    sys.exit(0 if ok else 1)


# ─────────────────────────────────────────────────────────────────────
# Argument parsing & entry point
# ─────────────────────────────────────────────────────────────────────
def main():
    ap = argparse.ArgumentParser("WebAuthn message modifier")
    ap.add_argument("--client", help="Base64URL clientDataJSON")
    ap.add_argument("--authdata", help="Base64URL authenticatorData")
    ap.add_argument("--attobj", help="Base64URL attestationObject (registration only)")

    ap.add_argument("--set-origin", help="Rewrite clientDataJSON.origin")
    ap.add_argument(
        "--set-challenge",
        help='Rewrite clientDataJSON.challenge '
        '(pass "random" for 32‑byte random value or Base64URL string)',
    )
    ap.add_argument(
        "--set-rpid",
        help="Set RP ID string and rewrite authenticatorData.rpIdHash (SHA‑256)",
    )

    ap.add_argument("--clear-UP", action="store_true", help="Clear UserPresence bit")
    ap.add_argument("--set-UP", action="store_true", help="Set UserPresence bit")
    ap.add_argument("--clear-UV", action="store_true", help="Clear UserVerification bit")
    ap.add_argument("--set-UV", action="store_true", help="Set UserVerification bit")
    ap.add_argument("--counter", type=int, help="Overwrite signatureCounter")
    ap.add_argument("--output", help="Write modified payload to file")
    ap.add_argument("--selftest", action="store_true", help="Run self‑tests and exit")

    args = ap.parse_args()

    if args.selftest:
        selftest()

    if not (args.client or args.authdata or args.attobj):
        ap.error("at least one of --client / --authdata / --attobj is required")

    modify(
        client_b64=args.client,
        authdata_b64=args.authdata,
        att_b64=args.attobj,
        set_origin=args.set_origin,
        set_challenge=args.set_challenge,
        set_rpid=args.set_rpid,
        clear_up=args.clear_UP,
        set_up=args.set_UP,
        clear_uv=args.clear_UV,
        set_uv=args.set_UV,
        counter=args.counter,
        output=args.output,
    )


if __name__ == "__main__":
    main()
###############################################################################
